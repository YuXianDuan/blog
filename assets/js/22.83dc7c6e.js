(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{438:function(s,a,e){"use strict";e.r(a);var t=e(2),r=Object(t.a)({},(function(){var s=this,a=s._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[a("h2",{attrs:{id:"为什么要使用webpack"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#为什么要使用webpack"}},[s._v("#")]),s._v(" 为什么要使用webpack")]),s._v(" "),a("ol",{attrs:{start:"0"}},[a("li",[s._v("开发时 使用的 一些框架(react vue) ES6 模块化语法 less sass等css预处理工具进行开发时 这样的代码想要在浏览器运行 必须编译成浏览器能识别的 js css 等语法 才能运行")]),s._v(" "),a("li",[s._v("压缩代码 兼容处理 提升代码性能")])]),s._v(" "),a("h2",{attrs:{id:"webpack是什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#webpack是什么"}},[s._v("#")]),s._v(" webpack是什么？")]),s._v(" "),a("h3",{attrs:{id:"webpack本身的功能非常有限-webpack是一个静态资源打包工具"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#webpack本身的功能非常有限-webpack是一个静态资源打包工具"}},[s._v("#")]),s._v(" webpack本身的功能非常有限 webpack是一个静态资源打包工具")]),s._v(" "),a("p",[s._v("1.开发模式：仅能编译js中的 ES Module 语法 像箭头函数 ，...运算符则不能编译需要借助插件 （mode=development）")]),s._v(" "),a("p",[s._v("2.生产模式：能编译 js中的 ES Module语法 还能压缩代码体积(mode=production)")]),s._v(" "),a("p",[s._v("###webpack 下载")]),s._v(" "),a("p",[s._v("安装webpac k npm i webpack webpack-cli -D 开发依赖")]),s._v(" "),a("p",[s._v("打包 npx webpack ./src/main.js --mode=development")]),s._v(" "),a("h2",{attrs:{id:"webpack基础"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#webpack基础"}},[s._v("#")]),s._v(" webpack基础")]),s._v(" "),a("h3",{attrs:{id:"webpack五大核心概念"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#webpack五大核心概念"}},[s._v("#")]),s._v(" webpack五大核心概念")]),s._v(" "),a("ol",{attrs:{start:"0"}},[a("li",[s._v("entry")]),s._v(" "),a("li",[s._v("output")]),s._v(" "),a("li",[s._v("loader")]),s._v(" "),a("li",[s._v("plugin")]),s._v(" "),a("li",[s._v("mode")])]),s._v(" "),a("h3",{attrs:{id:"打包方式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#打包方式"}},[s._v("#")]),s._v(" 打包方式")]),s._v(" "),a("p",[s._v("1.webpack-cli 配置")]),s._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("    2. webpack.config.js 配置 运行 npx webpack\n")])])]),a("h3",{attrs:{id:"开发模式需要做什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#开发模式需要做什么"}},[s._v("#")]),s._v(" 开发模式需要做什么")]),s._v(" "),a("p",[s._v("1.编译代码，使浏览器 识别运行 开发时图片资源，html资源webpack都不能识别所以需要加载配置来识别这些资源")]),s._v(" "),a("p",[s._v("2.代码质量检查")]),s._v(" "),a("h3",{attrs:{id:"处理样式资源"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#处理样式资源"}},[s._v("#")]),s._v(" 处理样式资源")]),s._v(" "),a("p",[s._v("1.借助loader来编译样式资源")]),s._v(" "),a("p",[s._v("1.[style-loader,css-loader]处理css资源")]),s._v(" "),a("p",[s._v("2.[style-loader,css-loader,sass-loader] 处理sass资源")]),s._v(" "),a("p",[s._v("例子：")]),s._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("module.exports ={\n    module:{\n        rules:[\n            {\n                //sass 和scss为后缀的文件\n                test: /.s[ac]ss$/i,\n                use:[\n                    style-loader,//将 js模块编译成一个style标签插入到html中\n                    css-loader,//将css文件编译成一个 common js模块 到js中\n                    sass-loader//将 sass编译成 css文件\n                ] \n            }\n        ]\n    }\n}\n")])])]),a("h3",{attrs:{id:"处理图片资源"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#处理图片资源"}},[s._v("#")]),s._v(" 处理图片资源")]),s._v(" "),a("p",[s._v("1.webpack4时对于图片资源使用 file-loader 和 url-loader处理")]),s._v(" "),a("p",[s._v("file-loader将图片资源变成 webpack可以识别的资源")]),s._v(" "),a("p",[s._v("url-loader将小于一定大小的图片转换成base64的格式")]),s._v(" "),a("p",[s._v("图片转化成base64后图片加载不需要额外发请求了，但是图片资源的大小会变大")]),s._v(" "),a("p",[s._v("2.webpack5已经将这两个loader 内置到webpack的内置功能中了，只需要通过配置去开启这两个功能 不需要loader 也就是说webpack本身已经支持这两个功能了")]),s._v(" "),a("p",[s._v("例子")]),s._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("module.exports={\n    module:{\n        rules:[\n            {\n                test:/.(png|gif|svg|jpe?g|webp)$/i,\n                type:'asset',\n                parser:{\n                   dataUrlCondition:{\n                       maxSize:20*1024,\n                   }\n                }\n            }\n        ]\n    }\n}\n")])])]),a("h3",{attrs:{id:"处理字体视频等静态资源-不需要进行base64-处理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#处理字体视频等静态资源-不需要进行base64-处理"}},[s._v("#")]),s._v(" 处理字体视频等静态资源 不需要进行base64 处理")]),s._v(" "),a("p",[s._v("例子：")]),s._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("module.exports={\n    module:{\n        rules:[\n            {\n                text:/.(ttf|woff2?|mp3|mp4|avi)$/,\n                type:'asset/resourse',\n                generator:{\n                    filename:'static/font/[hash:10][ext][query]'\n                }\n            }\n        ]\n    }\n}\n")])])]),a("h3",{attrs:{id:"webpack处理js-原因"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#webpack处理js-原因"}},[s._v("#")]),s._v(" webpack处理js 原因：")]),s._v(" "),a("p",[s._v("1.webpack本身只能对 ES Module模块化的处理 对于语法的新特性它并不支持")]),s._v(" "),a("p",[s._v("针对这个问题 我们使用 babel来完成 高级语法转Es5 语法")]),s._v(" "),a("p",[s._v("2.对于代码的格式是有严格要求的")]),s._v(" "),a("p",[s._v("针对这个问题我们使用EsLint代码检测工具来完成，先由 EsLint对代码格式检测在由babel对代码做兼容处理")]),s._v(" "),a("p",[s._v("###处理html资源")]),s._v(" "),a("p",[s._v("1.为什么要处理html资源？ 打包后的js资源我们希望webpack能自动引入")]),s._v(" "),a("p",[s._v("配置：")]),s._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("const HtmlWebpackPlugin = require('html-webpack-plugin')\nmodule.export={\n    plugins:[\n      new HtmlWebpackPlugin({\n            //以public/index.html为模板创建新的html文件\n            //1.结构与原来一致，\n            //2.自动打包引入原来的输出的资源\n                    template:path.resolve(__dirname,\"public/index.html\")\n        })   \n    ]\n}\n")])])]),a("p",[s._v("###开发模式下的打包")]),s._v(" "),a("p",[s._v("1.下载 webpack-dev-server这个包")]),s._v(" "),a("p",[s._v("配置")]),s._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("module.export={\n    devServer:{\n        host:'localhost',//html打开域名\n        port:'3000',//端口\n        open:'true'//运行后自动打开\n    }\n}\n")])])]),a("p",[s._v("使用 npx webpack sever启动")]),s._v(" "),a("h2",{attrs:{id:"生产模式下打包"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#生产模式下打包"}},[s._v("#")]),s._v(" 生产模式下打包")]),s._v(" "),a("h3",{attrs:{id:"css资源打包"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#css资源打包"}},[s._v("#")]),s._v(" css资源打包")]),s._v(" "),a("ol",{attrs:{start:"0"}},[a("li",[a("p",[s._v("开发模式下 css资源会通过 [css-loader,style-loader]打包成js资源，在去创建style标签 所以当js加载完后 才会给html插入style标签，加入样式")]),s._v(" "),a("p",[s._v("所以当用户网速比较慢的时候它会出现闪屏显现")])]),s._v(" "),a("li",[a("p",[s._v("正确处理方式: 单独打包 css 文件 通过link标签加载性能才好")])]),s._v(" "),a("li",[a("p",[s._v("下载插件:npm install --save-dev mini-css-extract-plugin 解决闪屏问题")])])]),s._v(" "),a("h3",{attrs:{id:"例子"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#例子"}},[s._v("#")]),s._v(" 例子")]),s._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("const MiniCssExtractPlugin = require(\"mini-css-extract-plugin\")\n​\nmodule.exports={\n    plugins:[\n        //单独提取css资源\n        new MiniCssExtractPlugin(\n            {\n                filename:'static/css/main.css'\n            }\n        )\n    ]\n}\n")])])]),a("h3",{attrs:{id:"css兼容处理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#css兼容处理"}},[s._v("#")]),s._v(" css兼容处理")]),s._v(" "),a("ol",{attrs:{start:"0"}},[a("li",[a("p",[s._v("下载包 postcss-loader postcss postcss-preser-env , postcss-loader 依赖于 postcss, postcss需要使用 postcss-preset-env智能预设解决样式兼容问题")])]),s._v(" "),a("li",[a("p",[s._v("例子")]),s._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("const MiniCssExtractPlugin = require(\"mini-css-extract-plugin\")\n​\nmodule.export={\n    module:{\n        rules:[\n            test:/.css$/,\n            use:[\n            //将js中的css编译成独立的资源\n             MiniCssExtractPlugin.loader,\n            \"css-loader\",\n            {\n                loader: 'postcss-loader',\n                    options: {\n                      postcssOptions: {\n                        plugins: ['postcss-preset-env',],\n                      },\n                    },\n            }\n        ]\n      ]\n    }\n}\n")])])]),a("h3",{attrs:{id:"css压缩"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#css压缩"}},[s._v("#")]),s._v(" css压缩")]),s._v(" "),a("p",[s._v("plugins：npm install css-minimizer-webpack-plugin --save-dev")]),s._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("new CssMinimizerPlugin()\n")])])]),a("h2",{attrs:{id:"webpack优化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#webpack优化"}},[s._v("#")]),s._v(" webpack优化")]),s._v(" "),a("h3",{attrs:{id:"提升开发体验"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#提升开发体验"}},[s._v("#")]),s._v(" 提升开发体验")]),s._v(" "),a("ol",{attrs:{start:"0"}},[a("li",[a("p",[s._v("SourceMap(源代码映射) 是一个用来生成源代码与构建后代码一一映射的文件方案， 它会生成一个 xxx.map文件从构建后代码的出错位置找到映射后源代码出错的位置，从而让浏览器找到映射后源代码出错的位置，帮助我们找到错误根源")])]),s._v(" "),a("li",[a("p",[s._v("开发模式：cheap-module-source-map")]),s._v(" "),a("ol",{attrs:{start:"0"}},[a("li",[s._v("优点：打包编译速度快,只包含行映射")]),s._v(" "),a("li",[s._v("缺点： 没有映射列")]),s._v(" "),a("li",[a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v('module.export={\n    mode:"development",\n    devtool:"cheap-module-source-map"\n}\n')])])])])])]),s._v(" "),a("li",[a("p",[s._v("生产模式： source-map")]),s._v(" "),a("ol",{attrs:{start:"0"}},[a("li",[s._v("优点：包含行列映射")]),s._v(" "),a("li",[s._v("缺点：打包编译速度更慢")]),s._v(" "),a("li",[a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v('module.export={\n    mode:"production",\n    devtool:"source-map"\n}\n')])])])])])]),s._v(" "),a("li",[a("p",[s._v("为什么开发模式要使用 cheap-module-source-map，生产模式要使用 source-map ，因为开发模式下代码不会进行压缩只需要映射到对应的行，生产模式代码只有一行 ，不加上列映射找不到错误")])])]),s._v(" "),a("h2",{attrs:{id:"提升打包速度"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#提升打包速度"}},[s._v("#")]),s._v(" 提升打包速度")]),s._v(" "),a("ol",{attrs:{start:"0"}},[a("li",[a("p",[s._v("HotModuleReplacement(HMR/热模块替换):在程序运行中 替换，添加，删除模块，无需重新加载整个页面 。就是不会重新打包整个项目，然后更新，只会更改 更改后文件对应的模块。")])]),s._v(" "),a("li",[a("p",[s._v("webpack不支持js的热模块更新，只支持 css sass less 等样式资源的热更新 原因与 浏览器的事件循环有关")])]),s._v(" "),a("li",[a("p",[s._v("给 js添加热模块替换 原始方案")]),s._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("if(module.hot){\n    //判断浏览器是否支持热更新模块\n    module.hot.accept('./js/count',\n                      //副作用函数\n                      ()=>{}\n                     )\n    module.hot.accept('./js/sum')\n}\n")])])])]),s._v(" "),a("li",[a("p",[s._v("oneof ， include/exclude")])]),s._v(" "),a("li",[a("p",[s._v("Cache 对 Eslint ，Babel编译的文件进行缓存 第二次打包时就不用所有文件都要通过babel处理，只有改变了个文件要Eslint ，Bael重新处理")])]),s._v(" "),a("li",[a("p",[s._v("Thead 开启多进程打包 我们前面提到过在生产模式下 打包好的 js文件会被默认压缩，其实是 Terser插件在处理，js压缩")])]),s._v(" "),a("li",[a("p",[s._v("开启多进程打包")]),s._v(" "),a("ol",{attrs:{start:"0"}},[a("li",[a("p",[s._v("先引入 os模块 通过 os.cpus().length()拿到cpu的核数")])]),s._v(" "),a("li",[a("p",[s._v("下载 npm i thread-loader -D")])]),s._v(" "),a("li",[a("p",[s._v("对 Eslint Babel Terser开启多进程")])]),s._v(" "),a("li",[a("p",[s._v("例子：")]),s._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("const ESLintPlugin = require('eslint-webpack-plugin')\nconst TerserWebpackPlugin = require(\"terser-webpack-plugin\")\nconst os = require('os')\nconst threads = os.cpus().length//进程数\nmodule.exports={\n    module:{\n        rules:{\n            oneOf:[\n                {\n                    test:.js$,\n                    use:[\n                    {\n                        loader:'thread-loader',//babel开启多进程\noption:{\n    works:threads//进程数\n}\n                    },{\n                    loader:'babel-loader',\n                    option:{\n                    \n                    }\n                    }\n                    ]\n                }\n            ]\n        }\n    }\n    plugins:[\n        //eslint检测\n        new ESLintPlugin({\n            threads,//eslint开启多进程\n        }),\n        //js压缩\n        new TerserWebpackPlugin({\n            parallel:threads\n        })\n    ]\n}\n")])])])])])])]),s._v(" "),a("h2",{attrs:{id:"优化打包体积"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#优化打包体积"}},[s._v("#")]),s._v(" 优化打包体积")]),s._v(" "),a("h3",{attrs:{id:"tree-sharking"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#tree-sharking"}},[s._v("#")]),s._v(" tree Sharking")]),s._v(" "),a("ol",{attrs:{start:"0"}},[a("li",[s._v("只打包引入并且使用过的模块")]),s._v(" "),a("li",[s._v("只支持 ES Module 语法")]),s._v(" "),a("li",[s._v("生产模式下默认开启")])]),s._v(" "),a("h3",{attrs:{id:"babel"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#babel"}},[s._v("#")]),s._v(" Babel")]),s._v(" "),a("ol",{attrs:{start:"0"}},[a("li",[s._v("Babel对文件代码做适用性时对每个文件都做了插入了辅助代码显然这其中包含了很多重复的代码，我们将这些辅助代码独立开成一个模块，然后其他模块对它进行引用。")]),s._v(" "),a("li",[s._v("npm i @babel/plugin-transfrom-runtime 禁止注入 runtime代码 ，并使它们引入独立出去的代码")])]),s._v(" "),a("h3",{attrs:{id:"压缩图片-image-minimizer"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#压缩图片-image-minimizer"}},[s._v("#")]),s._v(" 压缩图片 image minimizer")]),s._v(" "),a("ol",{attrs:{start:"0"}},[a("li",[a("p",[a("code",[s._v("npm i image-minimizer-webpack-plugin imagemin -D")])])]),s._v(" "),a("li",[a("p",[s._v("剩下需要下载的包：")]),s._v(" "),a("ol",{attrs:{start:"0"}},[a("li",[s._v("有损压缩："),a("code",[s._v("npm i imagemin-gifsicle imagemin-jpegtran imagemin-option imagemin-svgo -D")])]),s._v(" "),a("li",[s._v("无损压缩:``")])])])]),s._v(" "),a("h3",{attrs:{id:"代码分割-code-split"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#代码分割-code-split"}},[s._v("#")]),s._v(" 代码分割 code split")]),s._v(" "),a("ol",{attrs:{start:"0"}},[a("li",[s._v("打包代码时我们是将所有的代码打包到一个文件中，体积太大，不利有首屏加载，所以我们尽量生产多个js文件，渲染那个页面就加载某个js文件")]),s._v(" "),a("li",[s._v("代码分割，多入口打包 ，公共模块单独打包 chunk")])]),s._v(" "),a("h2",{attrs:{id:"优化代码运行性能"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#优化代码运行性能"}},[s._v("#")]),s._v(" 优化代码运行性能")]),s._v(" "),a("ol",{attrs:{start:"0"}},[a("li",[a("p",[s._v("模块动态导入 开启 chunks:all ,使用import自动导入")])]),s._v(" "),a("li",[a("p",[s._v("给动态导入的代码命名，给chunk命名")])]),s._v(" "),a("li",[a("p",[s._v("preload/prefetch 让浏览器空闲的时候加载需要懒加载或公共模块的chunk，避免了当需要加载的时候资源过大，用户体验不好。对chunk文件 做 preload引入")]),s._v(" "),a("ol",{attrs:{start:"0"}},[a("li",[s._v("preload: 告诉浏览器立即加载资源，只能加载当前页面的资源")]),s._v(" "),a("li",[s._v("prefetch：空闲时在加载，既可以加载当前页面的资源，也可以加载下一个需要使用的资源")]),s._v(" "),a("li",[s._v("共同点:都会加载，但不执行，都会有缓存")])])]),s._v(" "),a("li",[a("p",[s._v("Network-cache ,")]),s._v(" "),a("ol",{attrs:{start:"0"}},[a("li",[s._v("chunk文件更新 引入chunk的文件不用更新，使得能更好的使用缓存 加快打包速度，")]),s._v(" "),a("li",[s._v("使用 contenthash 输出的文件根据文件内容生成hash值文件不变hash值不变。")]),s._v(" "),a("li",[s._v("增加 runtimeChunk配置 生成 runtime时文件 ，runtime文件保存有文件之间依赖的hash值，当chunk文件变化时，只有chunk 和runtime变化，使得引用chunk的文件不受影响。")])]),s._v(" "),a("h2",{attrs:{id:"解决代码兼容性问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#解决代码兼容性问题"}},[s._v("#")]),s._v(" 解决代码兼容性问题")]),s._v(" "),a("ol",{attrs:{start:"0"}},[a("li",[s._v("Core.js 使用babel对js代码进行处理 ，使用@babel/preset-env只能解决部分兼容性问题可以处理 ，... ,箭头函数，但是对一些Es6+的代码就没办法处理比如 Promise async。")]),s._v(" "),a("li",[s._v("使用 Core-js专门做一些Es6以上的API兼容性处理，通过打补丁的形式。")])]),s._v(" "),a("h2",{attrs:{id:"pwa离线访问"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#pwa离线访问"}},[s._v("#")]),s._v(" PWA离线访问")]),s._v(" "),a("ol",{attrs:{start:"0"}},[a("li",[s._v("渐进式网络应用程序")])])])])])])])}),[],!1,null,null,null);a.default=r.exports}}]);