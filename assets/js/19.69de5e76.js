(window.webpackJsonp=window.webpackJsonp||[]).push([[19],{433:function(e,r,t){"use strict";t.r(r);var n=t(2),i=Object(n.a)({},(function(){var e=this,r=e._self._c;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h3",{attrs:{id:"fiber起源"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#fiber起源"}},[e._v("#")]),e._v(" Fiber起源")]),e._v(" "),r("p",[e._v("在React15及其以前，"),r("strong",[e._v("Reconciler")]),e._v("采用递归的方式创建虚拟DOM，而递归过程是不可中断的。如果组件树层级很深，那么递归会占用线程很多时间，造成卡顿。")]),e._v(" "),r("p",[e._v("为了解决这个问题，React将"),r("strong",[e._v("递归不可中断更新")]),e._v("重构为"),r("strong",[e._v("异步可中断更新，")]),e._v(" 由于曾经用于递归的虚拟DOM数据结构已经无法满足需要。于是，全新的Fiber架构应运而生。")]),e._v(" "),r("h3",{attrs:{id:"fiber的含义"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#fiber的含义"}},[e._v("#")]),e._v(" Fiber的含义")]),e._v(" "),r("p",[e._v("Fiber包括三层含义")]),e._v(" "),r("ol",[r("li",[e._v("作为架构来说，之前的React15 Rencociler采用递归的方式执行，数据保存在递归调用栈中，所以称为 stack Reconciler。 React16 Renconciler基于Fiber节点实现，被称为Fiber Reconciler。")]),e._v(" "),r("li",[e._v("作为静态的数据结构来说，每个Fiber结点对应一个 React element，保存了该组件对应的DOM节点信息。")]),e._v(" "),r("li",[e._v("作为动态的工作单元来说，每个Fiber节点保存了本次更新中该组件改变的状态，要执行的工作。")])]),e._v(" "),r("h3",{attrs:{id:"fiber的结构"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#fiber的结构"}},[e._v("#")]),e._v(" Fiber的结构")]),e._v(" "),r("p",[r("a",{attrs:{href:"https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiber.new.js#L117",target:"_blank",rel:"noopener noreferrer"}},[e._v("Fiber节点的属性定义"),r("OutboundLink")],1)]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("function FiberNode(\n  tag: WorkTag,\n  pendingProps: mixed,\n  key: null | string,\n  mode: TypeOfMode,\n) {\n  // 作为静态数据结构的属性\n  this.tag = tag; // Fiber对应的组件类型（Function Class Host）\n  this.key = key; // key用于diff\n  this.elementType = null; // 大部分情况同\n  this.type = null;\n  this.stateNode = null;\n\n  // 用于连接其他Fiber节点形成Fiber树\n  this.return = null; // 指向父级节点\n  this.child = null; // 指向子Fiber节点\n  this.sibling = null; // 指向兄弟节点\n  this.index = 0;\n\n  this.ref = null;\n\n  // 作为动态的工作单元的属性\n  this.pendingProps = pendingProps;\n  this.memoizedProps = null;\n  this.updateQueue = null;\n  this.memoizedState = null;\n  this.dependencies = null;\n\n  this.mode = mode;\n\n  this.effectTag = NoEffect;\n  this.nextEffect = null;\n\n  this.firstEffect = null;\n  this.lastEffect = null;\n\n  // 调度优先级相关\n  this.lanes = NoLanes;\n  this.childLanes = NoLanes;\n\n  // 指向该fiber在另一次更新时对应的fiber\n  this.alternate = null; // 连结 current 和 workInProgress树对应的Fiber节点\n}\n")])])]),r("h3",{attrs:{id:"fiber的工作原理"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#fiber的工作原理"}},[e._v("#")]),e._v(" Fiber的工作原理")]),e._v(" "),r("h4",{attrs:{id:"双缓存技术"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#双缓存技术"}},[e._v("#")]),e._v(" 双缓存技术")]),e._v(" "),r("p",[e._v("当我们用"),r("strong",[e._v("canvas")]),e._v("绘制动画，每一帧绘制前都会调用"),r("strong",[e._v("ctx.clearRect")]),e._v("清除上一帧的画面。")]),e._v(" "),r("p",[e._v("如果当前帧画面计算量比较大，导致清除上一帧画面到绘制当前帧画面之间有较长间隙，就会出现白屏。")]),e._v(" "),r("p",[e._v("为了解决这个问题，我们可以在内存中绘制当前帧动画，绘制完毕后直接用当前帧替换上一帧画面，由于省去了两帧替换间的计算时间，不会出现从白屏到出现画面的闪烁情况。")]),e._v(" "),r("p",[e._v("这种"),r("strong",[e._v("在内存中构建并直接替换")]),e._v("的技术叫做双缓存(opens new window)。")]),e._v(" "),r("p",[e._v("React使用“双缓存”来完成Fiber树的构建与替换——对应着DOM树的创建与更新。")]),e._v(" "),r("h4",{attrs:{id:"双缓存fiber树"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#双缓存fiber树"}},[e._v("#")]),e._v(" 双缓存Fiber树")]),e._v(" "),r("p",[e._v("在React中"),r("strong",[e._v("最多会同时存在两棵Fiber树")]),e._v("。当前屏幕上显示内容对应的Fiber树称为"),r("strong",[e._v("current Fiber")]),e._v("树，正在内存中构建的Fiber树称为"),r("strong",[e._v("workInProgress Fiber")]),e._v("树。")]),e._v(" "),r("p",[e._v("current Fiber树中的Fiber节点被称为current fiber，workInProgress Fiber树中的Fiber节点被称为workInProgress fiber，他们通过alternate属性连接。")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("currentFiber.alternate === workInProgressFiber;\nworkInProgressFiber.alternate === currentFiber;\n")])])]),r("p",[e._v("React应用的根节点通过使current指针在不同Fiber树的rootFiber间切换来完成current Fiber树指向的切换。")]),e._v(" "),r("p",[e._v("即当workInProgress Fiber树构建完成交给Renderer渲染在页面上后，应用根节点的current指针指向workInProgress Fiber树，此时workInProgress Fiber树就变为current Fiber树。")]),e._v(" "),r("p",[e._v("每次状态更新都会产生新的workInProgress Fiber树，通过current与workInProgress的替换，完成DOM更新。")]),e._v(" "),r("p",[e._v("接下来我们以具体例子讲解mount时、update时的构建/替换流程。")]),e._v(" "),r("h5",{attrs:{id:"mount时"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#mount时"}},[e._v("#")]),e._v(" mount时")]),e._v(" "),r("p",[e._v("考虑一下例子：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("function App() {\n  const [num, add] = useState(0);\n  return (\n    <p onClick={() => add(num + 1)}>{num}</p>\n  )\n}\n\nReactDOM.render(<App/>, document.getElementById('root'));\n")])])]),r("ol",[r("li",[e._v("首次执行ReactDOM.render会创建fiberRootNode（源码中叫fiberRoot）和rootFiber。其中fiberRootNode是整个应用的根节点，rootFiber是"),r("App"),e._v("所在组件树的根节点。")],1)]),e._v(" "),r("p",[e._v("之所以要区分fiberRootNode与rootFiber，是因为在应用中我们可以多次调用ReactDOM.render渲染不同的组件树，他们会拥有不同的rootFiber。但是整个应用的根节点只有一个，那就是fiberRootNode。")]),e._v(" "),r("p",[e._v("fiberRootNode的current会指向当前页面上已渲染内容对应Fiber树，即current Fiber树。")]),e._v(" "),r("p",[r("img",{attrs:{src:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f1dd8e22de3e42eb884bf2d9aa4046d1~tplv-k3u1fbpfcp-zoom-1.image",alt:""}})]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("fiberRootNode.current = rootFiber\n")])])]),r("p",[e._v("由于是首屏渲染，页面中还没有挂载任何DOM，所以fiberRootNode.current指向的rootFiber没有任何子Fiber节点（即current Fiber树为空）。")]),e._v(" "),r("ol",{attrs:{start:"2"}},[r("li",[e._v("接下来进入render阶段，根据组件返回的JSX在内存中依次创建Fiber节点并连接在一起构建Fiber树，被称为workInProgress Fiber树。（下图中右侧为内存中构建的树，左侧为页面显示的树）")])]),e._v(" "),r("p",[e._v("在构建workInProgress Fiber树时会尝试复用current Fiber树中已有的Fiber节点内的属性，在首屏渲染时只有rootFiber存在对应的current fiber（即rootFiber.alternate）。")]),e._v(" "),r("p",[r("img",{attrs:{src:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ee2f0563c7b8428aa5fc3775f13dff3b~tplv-k3u1fbpfcp-zoom-1.image",alt:""}})]),e._v(" "),r("ol",{attrs:{start:"3"}},[r("li",[e._v("图中右侧已构建完的workInProgress Fiber树在commit阶段渲染到页面。")])]),e._v(" "),r("p",[e._v("此时DOM更新为右侧树对应的样子。fiberRootNode的current指针指向workInProgress Fiber树使其变为current Fiber 树。")]),e._v(" "),r("h5",{attrs:{id:"update时"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#update时"}},[e._v("#")]),e._v(" upDate时")]),e._v(" "),r("ol",[r("li",[e._v("接下来我们点击p节点触发状态改变，这会开启一次新的render阶段并构建一棵新的workInProgress Fiber 树。")])]),e._v(" "),r("p",[r("img",{attrs:{src:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/13998dd878a34d229b3cd4e11146dc3b~tplv-k3u1fbpfcp-zoom-1.image",alt:""}})]),e._v(" "),r("p",[e._v("和mount时一样，workInProgress fiber的创建可以复用current Fiber树对应的节点数据。")]),e._v(" "),r("ol",{attrs:{start:"2"}},[r("li",[e._v("workInProgress Fiber 树在render阶段完成构建后进入commit阶段渲染到页面上。渲染完毕后，workInProgress Fiber 树变为current Fiber 树。")])]),e._v(" "),r("p",[r("img",{attrs:{src:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dd43155e1c044cefb6d631e5d3ac4985~tplv-k3u1fbpfcp-zoom-1.image",alt:""}})])])}),[],!1,null,null,null);r.default=i.exports}}]);